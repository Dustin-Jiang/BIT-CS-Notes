在数据库系统中，为了允许多个事务并发执行，同时保证数据库的一致性和隔离性，需要使用并发控制机制。加锁（Locking）是一种常用的并发控制方法，它通过控制事务对数据项的访问权限来协调它们的执行顺序。

主要的锁分类如下：

1.  **排他锁（Exclusive Lock, X）**
    *   **目的：** 用于需要修改（写入）数据项的操作。一个事务在对数据项 A 进行写操作之前，必须获得其排他锁 `l_X(A)`（或简写为 `l(A)`）[29, 51]。
    *   **兼容性：** 排他锁是最高级别的锁。当一个事务持有了数据项的排他锁时，**任何其他事务都不能**再获得该数据项的任何其他类型的锁（包括共享锁或排他锁本身）[31, 54, 55, 79]。排他锁与任何其他锁都不兼容 [55, 79]。

2.  **共享锁（Shared Lock, S）**
    *   **目的：** 用于需要读取数据项的操作。一个事务在对数据项 A 进行读操作之前，通常需要获得其共享锁 `l_S(A)` [49, 51]。
    *   **兼容性：** 共享锁允许多个事务同时读取同一个数据项。因此，一个事务持有的共享锁与**其他事务请求的共享锁是兼容的** [49, 54, 55, 79]。但是，共享锁与排他锁**不兼容** [54, 55, 79]。

3.  **更新锁（Update Lock, U）**
    *   **目的：** 教材中提到更新锁是为了处理事务先读取数据（可能需要 S 锁），之后再修改数据（需要 X 锁）时可能发生的特定死锁问题 [62, 63]。当事务知道它可能稍后会写数据时，会请求更新锁而不是共享锁 [63]。
    *   **兼容性：** 根据教材中的兼容矩阵 [64, 65]，更新锁 `l_U(A)` 的兼容性描述如下（请求者 vs 持有者）：
        * 请求 S 锁：持有 S (T), 持有 X (F), 持有 U (F)
        * 请求 X 锁：持有 S (F), 持有 X (F), 持有 U (F)
        * 请求 U 锁：持有 S (T), 持有 X (F), 持有 U (F)
        这表明，一个事务请求 U 锁时，只要数据项上只有 S 锁（由其他事务持有），就可以获得 U 锁 [63]。但一旦某个事务获得了 U 锁，其他任何事务就不能再获得 S, X, 或 U 锁 [64, 65]。U 锁可以升级为 X 锁 [63]。

4.  **意向锁（Intention Locks）**
    *   **背景：** 意向锁用于支持**多粒度锁定**（Multiple Granularity），即数据项被组织成一个层次结构（例如，数据库包含表，表包含页面，页面包含元组）[73, 74]。事务可以在不同粒度的级别上请求锁。为了在粗粒度（如表）和细粒度（如元组）之间协调，引入了意向锁。
    *   **目的：** 意向锁被设置在层次结构的较高层，用于通知其他事务，有事务打算在层次结构的较低层锁定该节点的一部分 [75]。
    *   **分类及兼容性（根据教材兼容矩阵 [78, 79]）：**
        *   **意向共享锁 (Intention Shared, IS):** 表示事务打算在较低级别获得共享锁。IS 锁兼容 IS, IX, S, SIX 锁，但不兼容 X 锁 [79]。
        *   **意向排他锁 (Intention Exclusive, IX):** 表示事务打算在较低级别获得排他锁。IX 锁兼容 IS, IX 锁，但不兼容 S, SIX, X 锁 [79]。
        *   **共享意向排他锁 (Shared Intention Exclusive, SIX):** 表示事务在该节点本身需要共享锁，并打算在较低级别获得排他锁。SIX 锁只兼容 IS 锁，不兼容 IX, S, SIX, X 锁 [79]。

5. **增量锁（Increment Lock）** [58, 59] 作为一种特殊类型的锁，用于特定的原子增量操作。

这些不同类型的锁以及它们之间的兼容性规则是数据库管理系统实现并发控制（尤其是基于锁的两阶段锁协议）的基础，它们帮助系统在允许多个事务并发执行的同时，维护数据的一致性和隔离性。

这些锁通常用于多粒度锁定（如行级、页级、表级），其中 IS 和 IX 是“意向锁”，表示某个事务打算在更低的粒度上加 S 或 X 锁。

![[锁的兼容矩阵]]

![[加锁协议]]