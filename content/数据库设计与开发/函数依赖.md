函数依赖（Functional Dependency，简称 FD）是对 [[关系模型]]（表结构）的一种断言或约束，它描述了关系中属性值之间的一种特定关系 [2]。

一个函数依赖 **X → Y**（读作“X 函数决定 Y”或“Y 函数依赖于 X”）是指，在关系 R 中，如果任意两个元组（行）在属性集 X 上拥有相同的值，那么它们在属性集 Y 上的值也必须相同 [2]。

*   **X**：被称为决定因素（Determinant）或左侧（Left-hand side），它可以是一个或多个属性的集合。
*   **Y**：被称为被决定因素（Dependent）或右侧（Right-hand side），它也可以是一个或多个属性的集合。

这意味着对于属性集 X 的每一个唯一值，属性集 Y 都有且只有一个唯一值与之对应。可以将其类比为数学中的函数关系：$f(X) = Y$。

**示例：**
考虑一个 `Drinkers` 关系，包含属性 `(name, addr, beersLiked, manf, favBeer)` [4]。
1.  **`name → addr`**：表示一个饮酒者的姓名函数决定其地址。这意味着，如果关系中有两个元组的 `name` 值相同（例如，都是“Janeway”），那么它们的 `addr` 值也必须相同（例如，都住在“Voyager”）[5]。
2.  **`beersLiked → manf`**：表示一种啤酒决定其制造商。这意味着，如果关系中有两个元组的 `beersLiked` 值相同（例如，都是“Bud”），那么它们的 `manf` 值也必须相同（例如，都是“A.B.”）[5]。

**函数依赖的类型：**

*  ![[平凡函数依赖]]
* ![[非平凡函数依赖]]
* ![[完全函数依赖]]
* ![[部分函数依赖]]
* ![[传递函数依赖]]

**函数依赖的重要性**

函数依赖是关系数据库设计理论的基石，尤其在 **范式理论（Normal Forms）** 中扮演核心角色，用于指导数据库模式的分解和优化 [1, 37]。
* **识别冗余 (Redundancy)**：FD 有助于发现数据中的冗余。例如，如果 `beersLiked → manf` 存在，但 `manf` 在 `Drinkers` 表中多次重复出现同一个啤酒的制造商信息，就存在冗余 [32]。
* **避免异常 (Anomalies)**：数据冗余会导致更新异常（Update Anomaly）、删除异常（Deletion Anomaly）和插入异常（Insertion Anomaly） [31, 33]。函数依赖的违反会导致这些问题。
    * **更新异常**：如果某个事实存在多处记录，只更新其中一处，可能导致数据不一致 [31, 33]。
    * **删除异常**：删除某个元组时，可能意外地丢失不应丢失的重要事实 [31, 33]。
    * **插入异常**：无法插入某些事实，除非插入其他不相关的事实 [31]。
* **确定键 (Keys)**：一个关系模式的 **超键** 是能够函数决定该关系中所有属性的属性集 [6]。而**键**是最小的超键，即其任何真子集都不能作为超键 [6]。函数依赖是发现和验证关系键的基础。
* **规范化 (Normalization)**：通过将关系分解为更小、更优化的关系，以消除冗余和各种异常。例如，第二范式（2NF）要求非主属性完全函数依赖于码 [66]，而第三范式（3NF）和 BCNF 则进一步处理传递依赖和非主属性对 [[超键]] 的依赖问题。
* **[[Armstrong 公理系统]]**：这是一套用于推理函数依赖的有效且完备的公理系统，包括自反律（Reflexivity）、增广律（Augmentation）和传递律（Transitivity）。这些规则允许我们从已知的 FD 集合推导出所有逻辑上蕴含的 FDs。

![[函数依赖定义证明]]

![[最小函数依赖]]]