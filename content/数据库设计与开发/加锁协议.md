以下几种加锁协议结合特定的规则来保证调度是冲突可串行化的：

1.  **基本排他锁 (Exclusive Lock) 与 [[两阶段锁协议]] (Two-Phase Locking, 2PL)**
    * **协议规则：**
        *   **良好形式的事务 (Well-formed transactions):** 事务 Ti 在对数据项 A 执行任何操作（读或写）之前，必须先获得 A 的排他锁 `li(A)`，并在完成对 A 的所有操作后释放该锁 `ui(A)` [30]。
        *   **合法的调度器 (Legal scheduler):** 调度器必须确保，当事务 Ti 持有数据项 A 的排他锁 `li(A)` 时，任何其他事务 Tj 都不能获得数据项 A 的任何锁 `lj(A)`（因为排他锁与其他任何锁都冲突） [31, 44]。
    * **保证冲突可串行化的机制：** 
	    * 教材中给出了定理 [47]，证明了遵循这三条规则的事务产生的调度一定是冲突可串行化的。
	    * 其证明依赖于一个引理 [46]：如果在调度的优先图 P(S) 中存在一条从事务 Ti 到 Tj 的边 ($Ti \to Tj$)，意味着 Ti 的一个操作 pi(A) 在 Tj 的一个冲突操作 qj(A) 之前发生 (pi(A) <S qj(A))，那么 Ti 释放第一个锁的动作 (SH(Ti)) 在 Tj 释放第一个锁的动作 (SH(Tj)) 之前发生 (SH(Ti) <S SH(Tj)) [46]。
	    * 如果调度 P(S) 存在一个环 $T1 \to T2 \to ... \to Tn \to T1$，根据上述引理，将推出 SH(T1) <S SH(T2) <S ... <S SH(Tn) <S SH(T1)，这导致了矛盾 [47]。因此，遵循两阶段锁协议的调度，其优先图必然是无环的，从而保证了调度是冲突可串行化的 [47]。

2.  **共享锁 (Shared Lock) 和排他锁 (Exclusive Lock) 与两阶段锁协议 (2PL)**
    *   **协议规则：** 这是标准的关系数据库管理系统中最常用的 2PL 版本。
        *   **良好形式的事务:** 事务 Ti 在读取数据项 A 之前，必须获得 A 的共享锁 `l-Si(A)`；在写入数据项 A 之前，必须获得 A 的排他锁 `l-Xi(A)`。所有锁最终都需要释放 [51]。事务如果先读后写同一数据项，可能需要将共享锁升级为排他锁 [53]。
        *   **合法的调度器:** 调度器必须根据 [[锁的兼容矩阵]] 来授予锁 [54, 55]。共享锁 (S) 与其他共享锁 (S) 兼容，但不与排他锁 (X) 兼容。排他锁 (X) 与任何其他锁 (S 或 X) 都不兼容 [55]。只有当事务请求的锁模式与数据项上当前所有已持有的锁模式都兼容时，才能授予锁 [66]。
	*   **保证冲突可串行化的机制：** 教材中明确指出，遵循 Shared/Exclusive 锁规则和两阶段锁协议的调度，其结果是冲突可串行化的 [56]。证明思路与基本排他锁的 2PL 类似 [57]，核心仍然是 2PL 特性确保了基于锁释放顺序的前趋关系是无环的，从而保证了优先图无环。共享锁的引入提高了并发度（多个事务可以同时读取同一数据项），但冲突的定义和 2PL 保证无环的原理保持不变。

3.  **树协议 (Tree Protocol)**
    *   **协议规则 (教材主要描述排他锁版本):** 假设数据库中的数据项组织成一个树形结构。
        * 事务 Ti 获得的第一个锁可以是树中的任何数据项。
        * 之后，事务 Ti 只能锁定节点 Q *当且仅当* Ti 已经持有了 Q 的父节点 `parent(Q)` 的锁。这意味着加锁操作是沿着树结构向下进行的。
        * 事务可以随时释放锁。**注意：** 与 2PL 不同，树协议不强制存在一个只释放锁的收缩阶段。
        * 事务释放某个数据项的锁后，不能再次锁定该数据项。
    * **保证冲突可串行化的机制：** 
	    * 教材提出树协议可以保证 [[冲突可串行化]]。尽管树协议不遵循 2PL，允许在增长阶段释放锁，但其通过限制加锁的方式（必须先锁父节点才能锁子节点）来防止优先图中出现环。如果事务 Ti 和 Tj 冲突，它们必然在某个共同祖先节点（可能就是冲突数据项 A 本身）上产生了依赖。树协议强制事务从根（或某个入口点）向下加锁，这种结构化的加锁顺序本身就足以防止形成依赖环。
	    * 例如，如果 Ti 锁定了 A 之前锁定了 `parent(A)`，而 Tj 后来也需要锁定 A，Tj 必须等待 Ti 释放 A。如果在 Tj 释放 A 后 Ti 又想锁定 A，它必须重新从根开始向下加锁（或从某个已锁定的祖先节点），但根据规则 4，它不能再次锁定 A。这种规则组合起来，确保了事务之间的冲突依赖不会形成循环。

总结来说，这三种协议都通过对事务加锁行为施加约束来保证冲突可串行化：
- 基本的 2PL 通过强制锁的增长和收缩阶段来防止环；
- 标准 2PL 在此基础上引入共享锁以提高并发，并维持 2PL 的原则；
- 而树协议则利用数据项的树形结构来约束加锁顺序，即使不完全遵守 2PL 也能防止环。