地址码字段用于指定操作数的存放地址。根据地址码的个数，指令可分为以下几种结构。地址码的解析方式由 [[寻址技术]] 决定。

## 四地址指令

结构：`OP | A1 | A2 | A3 | A4`

- **A1, A2**：操作数地址。
- **A3**：结果存放地址。
- **A4**：下一条指令的地址。
- **现状**：仅存在于设计者的草稿纸上，实际系统中通过硬件简化。

## 三地址指令

结构：`OP | A1 | A2 | A3`

- **简化**：取消 A4，由 CPU 内部的专用寄存器 **程序计数器 (PC)** 自动指向下一条指令（通常为 PC+1，这里的“1”指一条指令的长度）。 #重点
- **访存次数**：执行一条三地址指令通常需要访问 **4 次** 内存（取指令、取 A1、取 A2、存 A3）。 #重点
- **特点**：代码可读性好，指令条数少，但单条指令较长。

## 二地址指令

结构：`OP | A1 | A2`

- **简化**：取消 A3，结果通常存回 A1（目的操作数地址）。
- **访存次数**：通常仍需访问 **4 次** 内存（取指令、取 A1、取 A2、存回 A1）。
- **特点**：会破坏源操作数（A1 的原始内容被覆盖）。

## 一地址指令

结构：`OP | A1`

- **简化**：隐含第二个操作数，通常存放在 CPU 内部的 **累加寄存器 (ACC)** 中。
- **访存次数**：仅需访问 **2 次** 内存（取指令、取 A1），结果存回 ACC。 #重点
- **特点**：访存次数减少，但代码可读性较差，指令条数多。

## 零地址指令

结构：`OP`

- **特点**：不给出操作数地址。
- **应用**：通常与 **堆栈 (Stack)** 结构配合使用，遵循后进先出 (LIFO) 原则。

## 结构对比实例

计算 $A \times B + C - D / E + F$：

- **三地址指令**：需 5 条指令，访存次数较少，代码短，可读性强。
- **二地址指令**：需 7 条指令（需额外的数据移动），总访存次数增加。
- **一地址指令**：需 9 条指令，访存次数减少（因为使用了 ACC），但指令条数最多，可读性最差。
- **结论**：三地址指令在程序长度和便利性上有优势；一地址指令在减少硬件复杂度和单条指令访存上有优势。