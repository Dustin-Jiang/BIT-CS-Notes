移位运算是计算机中实现乘除法运算的基础，主要分为算术移位、逻辑移位和循环移位。

## 算术移位 (Arithmetic Shift)

算术移位针对**有符号数**，运算过程中必须保持符号位不变，仅改变数值位。

- **左移 (Left Shift)**:

    - 相当于 $\times 2$。
    - **规则**: 低位补 0，高位移出（若移出位与符号位不同则溢出）。

- **右移 (Right Shift)**:

    - 相当于 $\div 2$。
    - **规则**:
        - **正数**（原/补/反码）: 高位补 0，低位移出。
        - **负数**:
            - **原码**: 高位补 0。
            - **补码**: **高位补 1**。 #重点
            - **反码**: 高位补 1。

| 机器数类型  | 正数右移补位 | 负数右移补位 | 负数左移补位 |
| :----- | :----: | :----: | :----: |
| 原码     |   0    |   0    |   0    |
| **补码** | **0**  | **1**  | **0**  |
| 反码     |   0    |   1    |   1    |

> **注意**: 负数补码右移时补 1 是后续 Booth 乘法算法正确性的关键。

## 舍入方法 (Rounding)

在右移过程中，低位被移出可能导致精度损失。常见的舍入处理方法包括：

1. **恒舍 (Truncation)**: 直接丢弃移出的位。简单但误差大。
2. **冯·诺依曼舍入 (Von Neumann Rounding)**:
    - 无论移出的位是什么，都将保留位的最低位 (LSB) 置为 1。
    - 优点: 无需判断移出位。
    - 缺点: 可能改变偶数为奇数，最大误差为 $1/2$ LSB。
3. **下舍上入 (Round to Nearest / 0-discard 1-add)**:
    - 类似于“四舍五入”。
    - 若移出的最高位为 0，则直接丢弃；若为 1，则在保留位的最低位加 1。

## 逻辑移位与循环移位

详见 [[四大类指令]] 中的简要介绍。逻辑移位不考虑符号，总是补 0。
