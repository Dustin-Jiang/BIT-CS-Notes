定点数乘法通常通过“累加 + 移位”的方式实现，将乘法转化为加法。

## 规范与警告 #重点

- **严禁手工计算**: 考试中必须严格按照机器运算规则（如原码/补码一位乘法规则）进行移位加法计算。**严禁使用手工长乘法列式计算**，即使答案正确也记为 **0 分**。
- **位数保留**: 
    - 结果的数值位数必须完整。若乘数与被乘数均为 $n$ 位数值，则乘积应为 $2n$ 位（原码一位乘）或 $2n+1$ 位。
    - **即使末尾是 0 也必须写出**，不能随意截断或省略。
- **过程完整性**: 必须清晰列出初始设定（被乘数、乘数绝对值或补码）、寄存器状态变化过程。

## 原码一位乘法

- **原理**：绝对值相乘，符号位单独处理。
    - 积的符号：$S_p = S_x \oplus S_y$
    - 数值部分：$|X| \times |Y|$
- **硬件资源**：
    - 寄存器 A (部分积，初值 0)。
    - 寄存器 B (被乘数 $|X|$)。
    - 寄存器 C (乘数 $|Y|$，与 A 级联移位)。
- **规则**：
    - 检查乘数最低位 $Y_n$。
    - 若 $Y_n = 1$，部分积 $A \leftarrow A + |X|$
    - 若 $Y_n = 0$，部分积 $A \leftarrow A + 0$
    - **右移**：A and C 级联右移一位 (逻辑右移，高位补 0)。
    - 重复 $N$ 次（$N$ 为数值位数）。
- **特点**：需做 $N$ 次加法 and $N$ 次移位。

![[Pasted image 20260102172035.png]]

## 补码一位乘法 (Booth 算法)

- **原理**：符号位参与运算，将被乘数与乘数均以补码表示直接计算。
- **规则 (Booth Rule)**：
    1. 在乘数 $Y$ 最低位后增加一位附加位 $Y_{n+1}$，初值为 0。
    2. 每次根据 $(Y_n, Y_{n+1})$ 的取值决定操作：
       - **00 或 11**：部分积 $+0$，右移。
       - **01**：部分积 $+[X]_{补}$，右移。
       - **10**：部分积 $+[-X]_{补}$，右移。
    3. **移位**：按**补码右移规则**进行（正数补 0，负数补 1）。
    4. **次数**：进行 $N$ 次移位，**$N+1$ 次加法**。
       - **最后一步** (第 $N+1$ 次循环)：仅做加法操作，**不移位**。 #重点
- **硬件资源**：需 A, B, C 三个寄存器及一位附加位。B 存 $[X]_{补}$，C 存 $[Y]_{补}$。

![[Pasted image 20260102172106.png]]

## 关键点总结

- **运算对象**：
  - 原码一位乘法：使用绝对值（符号位单独处理）。
  - 补码（Booth）：使用补码表示，符号位参与计算，直接处理有符号数。

- **判定位**：
  - 原码：仅检查乘数最低位 $Y_n$（1 位）。
  - Booth：检查 $(Y_n, Y_{n+1})$（2 位），根据两位组合决定执行 $+[X]_{补}$、$+[-X]_{补}$ 或 $+0$。 #重点

- **加法操作**：
  - 原码：若 $Y_n=1$ 则部分积 $A\leftarrow A+|X|$，否则 $+0$。
  - Booth：按判定位执行 $+[X]_{补}$、$+[-X]_{补}$ 或 $+0$。

- **移位方式**：
  - 原码：逻辑右移（高位补 0）。
  - Booth：补码右移（算术右移，符号位扩展）。

- **循环次数与最后一步**：
  - 原码：进行 $N$ 次加法并 $N$ 次移位（结束时仍需移位）。
  - Booth：进行 $N+1$ 次加法和 $N$ 次移位，其中**第 $N+1$ 次仅做加法，不移位**。 #重点

- **优缺点 / 适用场景**：
  - 原码：实现简单，适合无符号或分开处理符号的场合。
  - Booth：能直接处理有符号乘法，通常在硬件实现中用于减少不必要的加法与移位操作。
