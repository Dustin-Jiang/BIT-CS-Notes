并行加法器由多个 [[全加器]] 组成，用于实现多位二进制数的加法运算。其性能瓶颈在于进位信号的传递速度。 #重点

## 进位产生与传递函数

为了提高速度，引入了两个辅助函数：

- **进位产生函数 (Carry Generate)**：$G_i = A_i B_i$
- **进位传递函数 (Carry Propagate)**：$P_i = A_i \oplus B_i$

进位公式可改写为：

$$C_i = G_i + P_i C_{i-1}$$

通过数学推导，可以将 $C_i$ 展开为仅与初始输入 $A, B, C_0$ 相关的式子，从而消除对前一级进位的依赖。

## 进位链设计

1. **串行进位 (Ripple Carry)**：
   - 进位信号逐级传递 ($C_0 \rightarrow C_1 \rightarrow \dots \rightarrow C_n$)。
   - **缺点**：速度最慢，总延迟随位数 $N$ 线性增长。若每级延迟为 $1\tau$，则总延迟为 $N\tau$。
   - *极端情况*：$11\dots1 + 00\dots1$ 会导致进位从最低位一直传递到最高位。

2. **先行进位 (Carry Lookahead, CLA)**：
   - 利用 $G_i$ 和 $P_i$ 提前计算进位。
   - 实际工程中常采用 **分组先行进位** 方案：
     
     - **单级先行进位 (CLA)**：
       - **组内并行，组间串行**。
       - 每个组（如 4 位 CLA）在接收到低位进位 $C_0$ 后，经过 $2\tau$ 延迟产生本组最高位进位 (如 $C_4$) 传递给下一组。
       - *时序*：$C_0 \xrightarrow{2\tau} C_4 \xrightarrow{2\tau} C_8 \xrightarrow{2\tau} C_{12} \dots$
       - 相比完全串行 ($N\tau$)，延迟大大降低，但随组数增加仍有线性延迟。
       
     - **多级先行进位 (BCLA / Block CLA)**：
       - **组内并行，组间也并行**。
       - 使用 **BCLA** 电路，它**不直接输出进位信号**，而是输出**组进位产生函数** $G^*$ 和 **组进位传递函数** $P^*$。
       - **结构**：
         - 底层：由多个 BCLA 加法器块组成，每个块并行产生内部进位，并计算本组的 $G^*$ 和 $P^*$。
         - 顶层：使用一个 CLA 单元接收所有底层的 $G^*$ 和 $P^*$，同时计算出所有组间的进位信号 ($C_4, C_8, \dots$)。
       - *特点*：进位信号 $C_{16}$ 可能比中间进位更早或同时产生，速度最快，但硬件最复杂。

## 性能优化

提高并行加法器速度的关键在于 **折衷**：在技术先进性（速度）和硬件复杂度（成本）之间找到平衡。 #重点

完全的先行进位会导致电路过于复杂，因此分组方案是主流选择。
