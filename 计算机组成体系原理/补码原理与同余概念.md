补码是计算机中处理有符号数的核心机制，其引入的主要目的是简化运算器设计。

## 核心目的

- 使符号位参与运算。
- **将减法运算转换为加法运算**，从而简化硬件电路。 #重点

## 理论基础

1. **模 (Modulo)**:
    - 指有限存储空间所能表示的数值总量。
    - **原理**: 计算机存储空间（寄存器）是有限的，当运算结果超出模时，高位会自然溢出并丢失。
    - 例如：8 位寄存器的模为 $2^8 = 256$。
2. **同余 (Congruence)**:
    - **类比：圆盘时针**: #重点
        - 设时钟的模为 12。
        - 若要将时针从 10 点拨到 8 点，有两种方法：
            1. **减法**: 逆时针拨 2 小时 ($10 - 2 = 8$)。
            2. **加法**: 顺时针拨 10 小时 ($(10 + 10) \mod 12 = 8$)。
        - 在模 12 的空间下，$-2$ 和 $+10$ 是**同余**的。
    - **补码应用**: 在特定的模空间下，为一个负数找到一个等价的正数。通过这种变换，**将减法运算转换为加法运算**。 #重点

## 补码的计算规则

- **正数**: $[X]_{原} = [X]_{补} = [X]_{反}$。
- **负数**:
    - 符号位保持不变。
    - 数值位“按位取反，末位加 1”。 #重点

## 补码的优势

- **统一加减法**: 符号位参与运算。计算机硬件中只需要设计**加法器**，减法、乘法、除法最终都转化为加法实现。 #重点
- **零的表示唯一**: $[+0]_{补} = [-0]_{补} = 000...0$。
- **表示范围更广**: 
    - 补码利用原码中“-0”的编码位置多表示了一个负数。
    - **定点整数**: 对于 $n+1$ 位补码，可表示 $-2^n$（如 8 位可表示 $-128$）。
    - **定点小数**: 对于 $n+1$ 位补码，可表示 $-1$。 #重点
    - **最小值**: 补码定点小数的最小值为 $-1$，且该值与字长（位数）无关。 #重点

## 进阶：进制转化与通用 R 进制

1. **基本进制**: 计算机常用二进制 (B)、八进制 (Q/O)、十六进制 (X/H)。
2. **通用 R 进制原理**:
    - **基数**: 包含 $0 \sim R-1$ 个符号。
    - **规则**: “逢 $R$ 进一，借一当 $R$”。
    - **多项式表示**: 任何 $R$ 进制数都可以展开为以 $R$ 为底的多项式，从而转化为十进制。 #重点

## 32 位系统与 4GB 寻址空间
- 理论上 $2^{32} = 4GB$。
- 在 32 位操作系统（如 Win7）下，由于系统预留和硬件映射，实际可用空间通常仅为 3.1GB~3.2GB 左右。若要充分利用 4GB 以上内存，必须安装 64 位操作系统。 #重点
