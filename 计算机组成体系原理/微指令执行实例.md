以指令 `ADD @R0, R1` 为例（寄存器间接寻址 + 寄存器直接寻址），展示微操作序列。

## 硬件前提

- 假设 CPU 为单总线结构。
- 每个寄存器均有输入开关（标记为 $in$）和输出开关（标记为 $out$）。

## 微操作序列分析

### 1. 取指公共操作 (T1-T3)

1. $PC_{out}, MAR_{in}, Read, ALU_{add}, C_0=1, Z_{in}$: 地址送主存，同时利用 ALU 完成 $(PC)+1 \rightarrow Z$。 #重点
2. $Z_{out}, PC_{in}$: 将更新后的地址写回 PC。
3. $MDR_{out}, IR_{in}$: 将读出的指令存入指令寄存器，并等待 MFC 信号。

### 2. 分析与取数 (T4-T5)

4. $R0_{out}, MAR_{in}, Read$: 取第一个操作数的有效地址（寄存器间接寻址）。
5. $R1_{out}, Y_{in}$: 将第二个操作数（寄存器直接寻址）存入暂存器 Y，等待主存读出第一个操作数。

### 3. 执行运算 (T6-T7)

6. $MDR_{out}, ALU_{add}, Z_{in}$: 将读出的操作数与 Y 相加，结果存入 Z。
7. $Z_{out}, MDR_{in}, Write$: 将结果写入 MDR 并发出写信号。

## 总结

- **微命令**: 如 $PC_{out}$，是控制逻辑的最小描述。
- **微操作**: 硬件开关的真实动作。
- 这一序列实现了“抽象 01 代码”到“电子设备具体动作”的转化。 #重点
