定点数除法采用“加减交替法” (Non-Restoring Division) 实现，避免了恢复余数法中繁琐的恢复步骤。

## 规范与警告 #重点

- **严禁手工计算**: 必须严格按照加减交替法的步骤（商、移位、加/减除数）进行。严禁直接列式除法，即使答案正确也记为 **0 分**。
- **位数保留**: 商和余数的位数必须与操作数一致。**即使末尾是 0 也必须写出**（如 `0.11000` 不能写成 `0.11`），否则视为不规范扣分。
- **算法差异**: 原码加减交替法与补码加减交替法计算出的**商和余数结果通常不同**（通常是商的最后一位有差异，余数差异较大）。这是算法特性，并非计算错误。 #重点
- **移位细节**: 除法运算中，部分新余数是向**左移**（相当于不断放大余数与除数比较）。

## 硬件资源

- 寄存器 A：存放被除数/余数 (初始为被除数)。
- 寄存器 B：存放除数。
- 寄存器 C：存放商 (初始为 0)。

## 原码加减交替法

- **原理**：绝对值运算，符号位单独处理 ($S_Q = S_X \oplus S_Y$)。
- **运算规则**：
    1. **第一步**：$R_0 = X - Y$ (即 $+[-Y]_{补}$)。
    2. **循环判断**：根据余数 $R_i$ 的符号决定商和下一步操作。
       - 若 $R_i > 0$ (正)：商 $Q_i = 1$，余数左移，**减除数** ($-|Y|$ 或 $+[-|Y|]_{补}$)。
       - 若 $R_i < 0$ (负)：商 $Q_i = 0$，余数左移，**加除数** ($+|Y|$)。
    3. **循环次数**：通常进行 $N+1$ 或 $N+2$ 次操作。
    4. **修正**：若最终余数为负，需 $+|Y|$ 恢复为正余数。
- **特点**：余数不恢复，直接根据符号决定加/减。

![[Pasted image 20260102173429.png]]

## 补码加减交替法

- **原理**：符号位参与运算，操作数以补码表示。
- **运算规则**：
    1. **第一步判定**：
       - 若被除数与除数 **同号**：做 **减法** ($X - Y$)。
       - 若被除数与除数 **异号**：做 **加法** ($X + Y$)。
    2. **循环判断** (根据**余数**与**除数**的符号关系)：
       - **同号**：商 $1$，余数左移，做 **减法**。
       - **异号**：商 $0$，余数左移，做 **加法**。
    3. **末位恒置 1**：为了简化逻辑，补码除法的商末位通常强制置 1 (误差在允许范围内)。 #重点
    4. **循环次数**：$N$ 次移位，$N+1$ 次加法。

### 计算示例 (补码加减交替)

**题目**：$X = 0.10000, Y = -0.1010$，求 $X \div Y$。
**解**：
1. **预处理**：
   - $[X]_{补} = 0.10000$ (被除数/初始余数 R)
   - $[Y]_{补} = 1.0110$ (除数)
   - $[-Y]_{补} = 0.1010$

| 步骤 | 操作说明 | 余数 (R) | 商 (Q) | 说明 |
| :--- | :--- | :--- | :--- | :--- |
| 1 (初) | X, Y 异号 $\rightarrow +Y$ | 0.10000 | | |
| | **+ [Y] 补** | 1.0110 | | |
| | **= 新余数 R0** | **1.1110** | | R0 与 Y 同号 (均为负) |
| 2 | $\because$ 同号 $\rightarrow Q_0=1$ | | 0.0001 | 上商 1 |
| | R0 左移 | 1.1100 | | |
| | **- Y (+[-Y] 补)** | 0.1010 | | 做减法 |
| | **= 新余数 R1** | **0.0110** | | R1(正) 与 Y(负) 异号 |
| 3 | $\because$ 异号 $\rightarrow Q_1=0$ | | 0.0010 | 上商 0 |
| | R1 左移 | 0.1100 | | |
| | **+ [Y] 补** | 1.0110 | | 做加法 |
| | **= 新余数 R2** | **0.0010** | | R2(正) 与 Y(负) 异号 |
| 4 | $\because$ 异号 $\rightarrow Q_2=0$ | | 0.0100 | 上商 0 |
| | R2 左移 | 0.1000 | | |
| | **+ [Y] 补** | 1.0110 | | 做加法 |
| | **= 新余数 R3** | **1.1110** | | R3(负) 与 Y(负) 同号 |
| 5 | $\because$ 同号 $\rightarrow Q_3=1$ | | 0.1001 | 上商 1 |
| | R3 左移 | 1.1100 | | |
| | **- Y (+[-Y] 补)** | 0.1010 | | 做减法 |
| | **= 新余数 R4** | **0.0110** | | |
| 结 | **末位恒置 1** | | **0.10011** | $Q_4$ 不再计算，直接置 1 |

**结果**：商 $[Q]_{补} = 1.0111$ (注意这里通常符号位单独处理或包含在商中，补码除法商的符号通常也是自动形成的，但末位恒置 1 可能引入误差)。
*注：本例根据课堂口述记录，重点在于“同号减上商 1，异号加上商 0”的规则演练。*

![[Pasted image 20260102173515.png]]
## 对比总结

- **符号处理**：
  - 原码加减交替法：符号单独处理（按绝对值运算，结果符号由 $S_X \oplus S_Y$ 决定）。
  - 补码加减交替法：符号参与运算，操作数与结果均以补码表示。

- **第一步**：
  - 原码：第一步通常做减法 $R_0 = X - Y$（即 $+[-Y]_{补}$）。
  - 补码：若被除数与除数同号则做减法，否则做加法（同号减，异号加）。

- **判定依据**：
  - 原码：根据余数符号决定商位与下一步操作（余数符号为正或负）。
  - 补码：根据余数与除数是否同号决定商位与下一步操作。 **#重点**

- **商的确定**：
  - 原码：正余数对应商位 1，负余数对应商位 0。
  - 补码：余数与除数同号则商位 1，异号则商位 0。

- **末位处理**：
  - 原码：按常规计算末位。
  - 补码：商的末位通常强制恒置为 1（以简化逻辑，误差在允许范围内）。 **#重点**

- **余数恢复**：
  - 原码：若最终余数为负，需加上除数绝对值恢复为正余数。
  - 补码：通常无需恢复（直接以补码形式结束）。

- **循环次数与其他**：
  - 原码：通常进行 $N+1$ 或 $N+2$ 次操作（视具体实现而定）。
  - 补码：通常为 $N$ 次移位，$N+1$ 次加法。

- **适用场景 / 优缺点**：
  - 原码：实现直观、易理解，适用于以绝对值分开处理符号的场合。
  - 补码：适合硬件直接实现有符号除法，可减少恢复等额外步骤，便于流水线和统一算术单元使用。
